from PyQt5.QtWidgets import (QWidget, QVBoxLayout, QGridLayout, QLabel, QPushButton, 
                          QLineEdit, QTextEdit, QGroupBox, QComboBox, QTableWidget,
                          QTableWidgetItem, QHeaderView, QProgressBar, QHBoxLayout,
                          QCheckBox, QSpinBox, QTabWidget)
from PyQt5.QtCore import Qt, QThread, pyqtSignal

class HeaderAnalyzerThread(QThread):
    """Thread for HTTP header analysis operations."""
    result_signal = pyqtSignal(dict)
    error_signal = pyqtSignal(str)
    
    def __init__(self, url):
        super().__init__()
        self.url = url
        
    def run(self):
        try:
            from src.tools.web_pentest.http_header_analyzer import HTTPHeaderAnalyzer
            
            analyzer = HTTPHeaderAnalyzer()
            results = analyzer.analyze(self.url)
            
            self.result_signal.emit(results)
            
        except Exception as e:
            self.error_signal.emit(str(e))


class SubdomainScannerThread(QThread):
    """Thread for subdomain scanning operations."""
    result_signal = pyqtSignal(dict)
    progress_signal = pyqtSignal(int, int)  # current, total
    error_signal = pyqtSignal(str)
    
    def __init__(self, domain, wordlist=None, max_threads=10):
        super().__init__()
        self.domain = domain
        self.wordlist = wordlist
        self.max_threads = max_threads
        
    def run(self):
        try:
            from src.tools.web_pentest.subdomain_scanner import SubdomainScanner
            
            scanner = SubdomainScanner()
            
            def progress_callback(current, total):
                self.progress_signal.emit(current, total)
            
            results = scanner.scan(
                self.domain, 
                wordlist=self.wordlist,
                max_threads=self.max_threads,
                progress_callback=progress_callback
            )
            
            self.result_signal.emit(results)
            
        except Exception as e:
            self.error_signal.emit(str(e))


class XSSVulnerabilityScannerThread(QThread):
    """Thread for XSS vulnerability scanning operations."""
    result_signal = pyqtSignal(dict)
    progress_signal = pyqtSignal(int, int)  # current, total
    error_signal = pyqtSignal(str)
    
    def __init__(self, url, forms_only=False, test_all_params=True):
        super().__init__()
        self.url = url
        self.forms_only = forms_only
        self.test_all_params = test_all_params
        
    def run(self):
        try:
            from src.tools.web_pentest.xss_scanner import XSSScanner
            
            scanner = XSSScanner()
            
            def progress_callback(current, total):
                self.progress_signal.emit(current, total)
            
            results = scanner.scan(
                self.url, 
                forms_only=self.forms_only,
                test_all_params=self.test_all_params,
                progress_callback=progress_callback
            )
            
            self.result_signal.emit(results)
            
        except Exception as e:
            self.error_signal.emit(str(e))


class SQLInjectionScannerThread(QThread):
    """Thread for SQL injection scanning operations."""
    result_signal = pyqtSignal(dict)
    progress_signal = pyqtSignal(dict)
    error_signal = pyqtSignal(str)
    
    def __init__(self, url, scan_level='basic', forms=True, parameters=True, timeout_detection=True):
        super().__init__()
        self.url = url
        self.scan_level = scan_level
        self.forms = forms
        self.parameters = parameters
        self.timeout_detection = timeout_detection
        
    def run(self):
        try:
            # Fix the import path to use the correct module path
            from src.tools.pentest.sql_injection_scanner import SQLInjectionScanner
            
            scanner = SQLInjectionScanner()
            
            def progress_callback(data):
                self.progress_signal.emit(data)
            
            results = scanner.scan(
                self.url, 
                scan_level=self.scan_level,
                forms=self.forms,
                parameters=self.parameters,
                timeout_detection=self.timeout_detection,
                callback=progress_callback
            )
            
            self.result_signal.emit(results)
            
        except Exception as e:
            self.error_signal.emit(str(e))


class WebPentestTab(QWidget):
    def __init__(self):
        super().__init__()
        
        # Create main layout
        self.layout = QVBoxLayout(self)
        
        # Create a tab widget for pentest tools
        self.tabs = QTabWidget()
        
        # Create individual tool tabs
        self.header_analyzer_tab = self._create_header_analyzer_section()
        self.subdomain_scanner_tab = self._create_subdomain_scanner_section()
        self.xss_scanner_tab = self._create_xss_scanner_section()
        self.sql_injection_tab = self._create_sql_injection_scanner_section()
        
        # Add tool tabs to tab widget
        self.tabs.addTab(self.header_analyzer_tab, "HTTP Headers")
        self.tabs.addTab(self.subdomain_scanner_tab, "Subdomain Scanner")
        self.tabs.addTab(self.xss_scanner_tab, "XSS Scanner")
        self.tabs.addTab(self.sql_injection_tab, "SQL Injection")
        
        # Add tab widget to main layout
        self.layout.addWidget(self.tabs)
        
        # Initialize threads
        self.header_thread = None
        self.subdomain_thread = None
        self.xss_thread = None
        self.sql_thread = None
        
        # Flag to track if tab is visible
        self.is_visible = False
        
    def _create_header_analyzer_section(self):
        """Create HTTP Header Analyzer section."""
        group = QGroupBox("HTTP Header Security Analyzer")
        layout = QVBoxLayout()
        
        # Input fields
        input_layout = QGridLayout()
        
        input_layout.addWidget(QLabel("URL:"), 0, 0)
        self.header_url_input = QLineEdit()
        self.header_url_input.setPlaceholderText("https://example.com")
        input_layout.addWidget(self.header_url_input, 0, 1)
        
        self.header_analyze_button = QPushButton("Analyze Headers")
        self.header_analyze_button.clicked.connect(self.perform_header_analysis)
        input_layout.addWidget(self.header_analyze_button, 1, 1)
        
        layout.addLayout(input_layout)
        
        # Results table
        self.header_results_table = QTableWidget(0, 3)
        self.header_results_table.setHorizontalHeaderLabels(["Header", "Value", "Security Assessment"])
        
        # Set column widths
        header = self.header_results_table.horizontalHeader()
        header.setSectionResizeMode(0, QHeaderView.ResizeToContents)
        header.setSectionResizeMode(1, QHeaderView.Stretch)
        header.setSectionResizeMode(2, QHeaderView.ResizeToContents)
        
        # Optimize table for performance
        self.header_results_table.setAlternatingRowColors(True)
        self.header_results_table.setVerticalScrollMode(QTableWidget.ScrollPerPixel)
        self.header_results_table.setHorizontalScrollMode(QTableWidget.ScrollPerPixel)
        
        layout.addWidget(self.header_results_table)
        
        # Status section
        status_layout = QHBoxLayout()
        
        self.header_status_label = QLabel("Ready")
        status_layout.addWidget(self.header_status_label)
        
        self.header_progress_bar = QProgressBar()
        self.header_progress_bar.setRange(0, 100)
        self.header_progress_bar.setValue(0)
        self.header_progress_bar.setVisible(False)
        status_layout.addWidget(self.header_progress_bar)
        
        layout.addLayout(status_layout)
        
        group.setLayout(layout)
        return group
    
    def _create_subdomain_scanner_section(self):
        """Create Subdomain Scanner section."""
        group = QGroupBox("Subdomain Scanner")
        layout = QVBoxLayout()
        
        # Input fields
        input_layout = QGridLayout()
        
        input_layout.addWidget(QLabel("Domain:"), 0, 0)
        self.subdomain_domain_input = QLineEdit()
        self.subdomain_domain_input.setPlaceholderText("example.com")
        input_layout.addWidget(self.subdomain_domain_input, 0, 1)
        
        input_layout.addWidget(QLabel("Wordlist:"), 1, 0)
        self.subdomain_wordlist_input = QComboBox()
        self.subdomain_wordlist_input.addItems(["Default (small)", "Medium", "Large"])
        input_layout.addWidget(self.subdomain_wordlist_input, 1, 1)
        
        input_layout.addWidget(QLabel("Threads:"), 2, 0)
        self.subdomain_threads_input = QSpinBox()
        self.subdomain_threads_input.setRange(1, 20)
        self.subdomain_threads_input.setValue(10)
        input_layout.addWidget(self.subdomain_threads_input, 2, 1)
        
        self.subdomain_scan_button = QPushButton("Scan Subdomains")
        self.subdomain_scan_button.clicked.connect(self.perform_subdomain_scan)
        input_layout.addWidget(self.subdomain_scan_button, 3, 1)
        
        layout.addLayout(input_layout)
        
        # Results table
        self.subdomain_results_table = QTableWidget(0, 2)
        self.subdomain_results_table.setHorizontalHeaderLabels(["Subdomain", "IP Address"])
        
        # Set column widths
        header = self.subdomain_results_table.horizontalHeader()
        header.setSectionResizeMode(0, QHeaderView.Stretch)
        header.setSectionResizeMode(1, QHeaderView.ResizeToContents)
        
        # Optimize table for performance
        self.subdomain_results_table.setAlternatingRowColors(True)
        self.subdomain_results_table.setVerticalScrollMode(QTableWidget.ScrollPerPixel)
        self.subdomain_results_table.setHorizontalScrollMode(QTableWidget.ScrollPerPixel)
        
        layout.addWidget(self.subdomain_results_table)
        
        # Status section
        status_layout = QHBoxLayout()
        
        self.subdomain_status_label = QLabel("Ready")
        status_layout.addWidget(self.subdomain_status_label)
        
        self.subdomain_progress_bar = QProgressBar()
        self.subdomain_progress_bar.setRange(0, 100)
        self.subdomain_progress_bar.setValue(0)
        self.subdomain_progress_bar.setVisible(False)
        status_layout.addWidget(self.subdomain_progress_bar)
        
        layout.addLayout(status_layout)
        
        group.setLayout(layout)
        return group
    
    def _create_xss_scanner_section(self):
        """Create XSS Scanner section."""
        group = QGroupBox("XSS Vulnerability Scanner")
        layout = QVBoxLayout()
        
        # Input fields
        input_layout = QGridLayout()
        
        input_layout.addWidget(QLabel("URL:"), 0, 0)
        self.xss_url_input = QLineEdit()
        self.xss_url_input.setPlaceholderText("https://example.com")
        input_layout.addWidget(self.xss_url_input, 0, 1)
        
        self.xss_forms_only = QCheckBox("Test forms only")
        self.xss_forms_only.setChecked(True)
        input_layout.addWidget(self.xss_forms_only, 1, 0)
        
        self.xss_all_params = QCheckBox("Test all parameters")
        self.xss_all_params.setChecked(True)
        input_layout.addWidget(self.xss_all_params, 1, 1)
        
        self.xss_scan_button = QPushButton("Scan for XSS Vulnerabilities")
        self.xss_scan_button.clicked.connect(self.perform_xss_scan)
        input_layout.addWidget(self.xss_scan_button, 2, 1)
        
        layout.addLayout(input_layout)
        
        # Results text
        self.xss_results = QTextEdit()
        self.xss_results.setReadOnly(True)
        layout.addWidget(self.xss_results)
        
        # Status section
        status_layout = QHBoxLayout()
        
        self.xss_status_label = QLabel("Ready")
        status_layout.addWidget(self.xss_status_label)
        
        self.xss_progress_bar = QProgressBar()
        self.xss_progress_bar.setRange(0, 100)
        self.xss_progress_bar.setValue(0)
        self.xss_progress_bar.setVisible(False)
        status_layout.addWidget(self.xss_progress_bar)
        
        layout.addLayout(status_layout)
        
        group.setLayout(layout)
        return group

    def _create_sql_injection_scanner_section(self):
        """Create SQL Injection Scanner section with improved layout."""
        group = QGroupBox("SQL Injection Vulnerability Scanner")
        layout = QVBoxLayout()
        layout.setContentsMargins(10, 15, 10, 10)  # Add proper margins
        
        # URL and scan level section
        input_section = QGroupBox("Target Configuration")
        input_layout = QGridLayout(input_section)
        input_layout.setVerticalSpacing(10)
        
        # Add URL input with improved layout
        url_label = QLabel("Target URL:")
        url_label.setStyleSheet("font-weight: bold;")
        self.sql_url_input = QLineEdit()
        self.sql_url_input.setPlaceholderText("https://example.com")
        self.sql_url_input.setMinimumHeight(28)  # Taller input field
        input_layout.addWidget(url_label, 0, 0)
        input_layout.addWidget(self.sql_url_input, 0, 1)
        
        # Add scan level with improved layout
        level_label = QLabel("Scan Intensity:")
        level_label.setStyleSheet("font-weight: bold;")
        self.sql_scan_level = QComboBox()
        self.sql_scan_level.addItems(["Basic", "Advanced", "Full"])
        self.sql_scan_level.setMinimumHeight(28)
        self.sql_scan_level.setToolTip("Basic: Fast scan with fewer tests\nAdvanced: More thorough scanning\nFull: Complete scan with all tests (slower)")
        input_layout.addWidget(level_label, 1, 0)
        input_layout.addWidget(self.sql_scan_level, 1, 1)
        
        layout.addWidget(input_section)
        
        # Options section with visual grouping
        options_section = QGroupBox("Scan Options")
        options_layout = QVBoxLayout(options_section)
        
        # Add checkbox options with better organization
        self.sql_forms_checkbox = QCheckBox("Test Forms")
        self.sql_forms_checkbox.setChecked(True)
        self.sql_forms_checkbox.setToolTip("Scan for vulnerabilities in HTML forms")
        
        self.sql_params_checkbox = QCheckBox("Test URL Parameters")
        self.sql_params_checkbox.setChecked(True)
        self.sql_params_checkbox.setToolTip("Scan URL query parameters for vulnerabilities")
        
        self.sql_timeout_checkbox = QCheckBox("Enable Time-based Detection")
        self.sql_timeout_checkbox.setChecked(True)
        self.sql_timeout_checkbox.setToolTip("Detect vulnerabilities that cause time delays (more thorough but slower)")
        
        options_layout.addWidget(self.sql_forms_checkbox)
        options_layout.addWidget(self.sql_params_checkbox)
        options_layout.addWidget(self.sql_timeout_checkbox)
        
        layout.addWidget(options_section)
        
        # Add scan button with improved style
        self.sql_scan_button = QPushButton("Scan for SQL Injection Vulnerabilities")
        self.sql_scan_button.setMinimumHeight(36)  # Taller button
        self.sql_scan_button.setCursor(Qt.PointingHandCursor)  # Hand cursor on hover
        self.sql_scan_button.clicked.connect(self.perform_sql_injection_scan)
        layout.addWidget(self.sql_scan_button)
        
        # Add status section with better visualization
        status_section = QWidget()
        status_layout = QVBoxLayout(status_section)
        status_layout.setContentsMargins(0, 5, 0, 5)
        
        # Add status label and indicator
        status_header = QHBoxLayout()
        self.sql_status_indicator = QLabel("⬤")  # Circle indicator
        self.sql_status_indicator.setStyleSheet("color: gray;")  # Gray = idle
        self.sql_status_indicator.setFixedWidth(20)
        self.sql_status_label = QLabel("Ready")
        
        status_header.addWidget(self.sql_status_indicator)
        status_header.addWidget(self.sql_status_label)
        status_header.addStretch()
        status_layout.addLayout(status_header)
        
        self.sql_progress_bar = QProgressBar()
        self.sql_progress_bar.setRange(0, 100)
        self.sql_progress_bar.setValue(0)
        self.sql_progress_bar.setVisible(False)
        status_layout.addWidget(self.sql_progress_bar)
        
        layout.addWidget(status_section)
        
        # Results area with improved formatting
        results_label = QLabel("Scan Results:")
        results_label.setStyleSheet("font-weight: bold; margin-top: 10px;")
        layout.addWidget(results_label)
        
        self.sql_results = QTextEdit()
        self.sql_results.setReadOnly(True)
        self.sql_results.setMinimumHeight(200)  # Taller results area
        layout.addWidget(self.sql_results)
        
        group.setLayout(layout)
        return group
    
    def perform_header_analysis(self):
        """Perform HTTP header analysis in a separate thread."""
        url = self.header_url_input.text().strip()
        if not url:
            self.header_status_label.setText("Error: Please enter a URL")
            return
        
        # Add http:// prefix if missing
        if not url.startswith("http://") and not url.startswith("https://"):
            url = "https://" + url
            self.header_url_input.setText(url)
        
        # Update UI
        self.header_analyze_button.setEnabled(False)
        self.header_status_label.setText(f"Analyzing headers for {url}...")
        self.header_progress_bar.setVisible(True)
        self.header_progress_bar.setValue(30)
        self.header_results_table.setRowCount(0)
        
        # Start thread
        self.header_thread = HeaderAnalyzerThread(url)
        self.header_thread.result_signal.connect(self.handle_header_results)
        self.header_thread.error_signal.connect(self.handle_header_error)
        self.header_thread.start()
    
    def handle_header_results(self, results):
        """Handle HTTP header analysis results."""
        self.header_progress_bar.setValue(100)
        
        # Clear previous results
        self.header_results_table.setRowCount(0)
        
        if 'headers' in results and results['headers']:
            # Add results to the table
            security_score = 0
            max_score = 0
            
            for header in results['headers']:
                row = self.header_results_table.rowCount()
                self.header_results_table.insertRow(row)
                
                # Add header name
                name_item = QTableWidgetItem(header.get('name', ''))
                self.header_results_table.setItem(row, 0, name_item)
                
                # Add header value
                value_item = QTableWidgetItem(header.get('value', ''))
                self.header_results_table.setItem(row, 1, value_item)
                
                # Add security assessment
                assessment = header.get('assessment', '')
                assessment_item = QTableWidgetItem(assessment)
                
                # Color-code based on security assessment
                if 'good' in assessment.lower():
                    assessment_item.setBackground(Qt.green)
                    security_score += 1
                elif 'warning' in assessment.lower() or 'missing' in assessment.lower():
                    assessment_item.setBackground(Qt.yellow)
                elif 'vulnerable' in assessment.lower() or 'critical' in assessment.lower():
                    assessment_item.setBackground(Qt.red)
                
                max_score += 1
                self.header_results_table.setItem(row, 2, assessment_item)
            
            # Calculate security score as percentage
            if max_score > 0:
                score_percentage = (security_score / max_score) * 100
                score_text = f"Security Score: {security_score}/{max_score} ({score_percentage:.1f}%)"
                self.header_status_label.setText(score_text)
            else:
                self.header_status_label.setText("Headers analyzed successfully")
        else:
            self.header_status_label.setText("No headers found or could not analyze")
        
        # Re-enable UI
        self.header_analyze_button.setEnabled(True)
        self.header_progress_bar.setVisible(False)
    
    def handle_header_error(self, error):
        """Handle HTTP header analysis error."""
        self.header_status_label.setText(f"Error: {error}")
        self.header_progress_bar.setValue(0)
        self.header_progress_bar.setVisible(False)
        self.header_analyze_button.setEnabled(True)
    
    def perform_subdomain_scan(self):
        """Perform subdomain scanning in a separate thread."""
        domain = self.subdomain_domain_input.text().strip()
        if not domain:
            self.subdomain_status_label.setText("Error: Please enter a domain")
            return
        
        # Get wordlist selection
        wordlist_selection = self.subdomain_wordlist_input.currentText()
        if wordlist_selection == "Default (small)":
            wordlist = None  # Use default
        elif wordlist_selection == "Medium":
            wordlist = "medium"
        else:  # Large
            wordlist = "large"
        
        # Get thread count
        max_threads = self.subdomain_threads_input.value()
        
        # Update UI
        self.subdomain_scan_button.setEnabled(False)
        self.subdomain_status_label.setText(f"Scanning subdomains for {domain}...")
        self.subdomain_progress_bar.setVisible(True)
        self.subdomain_progress_bar.setValue(0)
        self.subdomain_results_table.setRowCount(0)
        
        # Start thread
        self.subdomain_thread = SubdomainScannerThread(domain, wordlist, max_threads)
        self.subdomain_thread.result_signal.connect(self.handle_subdomain_results)
        self.subdomain_thread.progress_signal.connect(self.update_subdomain_progress)
        self.subdomain_thread.error_signal.connect(self.handle_subdomain_error)
        self.subdomain_thread.start()
    
    def update_subdomain_progress(self, current, total):
        """Update progress bar for subdomain scanning."""        
        if total > 0:
            progress = int((current / total) * 100)
            self.subdomain_progress_bar.setValue(progress)
            self.subdomain_status_label.setText(f"Scanning subdomains: {current}/{total} ({progress}%)")
    
    def handle_subdomain_results(self, results):
        """Handle subdomain scanning results."""        
        self.subdomain_progress_bar.setValue(100)
        
        # Clear previous results
        self.subdomain_results_table.setRowCount(0)
        
        if 'subdomains' in results and results['subdomains']:
            # Add results to the table
            for subdomain in results['subdomains']:
                row = self.subdomain_results_table.rowCount()
                self.subdomain_results_table.insertRow(row)
                
                # Add subdomain name
                name_item = QTableWidgetItem(subdomain.get('name', ''))
                self.subdomain_results_table.setItem(row, 0, name_item)
                
                # Add IP address
                ip_item = QTableWidgetItem(subdomain.get('ip', ''))
                self.subdomain_results_table.setItem(row, 1, ip_item)
            
            self.subdomain_status_label.setText(f"Found {len(results['subdomains'])} subdomains")
        else:
            self.subdomain_status_label.setText("No subdomains found")
        
        # Re-enable UI
        self.subdomain_scan_button.setEnabled(True)
        self.subdomain_progress_bar.setVisible(False)
    
    def handle_subdomain_error(self, error):
        """Handle subdomain scanning error."""
        self.subdomain_status_label.setText(f"Error: {error}")
        self.subdomain_progress_bar.setValue(0)
        self.subdomain_progress_bar.setVisible(False)
        self.subdomain_scan_button.setEnabled(True)
    
    def perform_xss_scan(self):
        """Perform XSS vulnerability scanning in a separate thread."""
        url = self.xss_url_input.text().strip()
        if not url:
            self.xss_status_label.setText("Error: Please enter a URL")
            return
        
        # Add http:// prefix if missing
        if not url.startswith("http://") and not url.startswith("https://"):
            url = "https://" + url
            self.xss_url_input.setText(url)
        
        # Get options
        forms_only = self.xss_forms_only.isChecked()
        test_all_params = self.xss_all_params.isChecked()
        
        # Update UI
        self.xss_scan_button.setEnabled(False)
        self.xss_status_label.setText(f"Scanning {url} for XSS vulnerabilities...")
        self.xss_progress_bar.setVisible(True)
        self.xss_progress_bar.setValue(0)
        self.xss_results.clear()
        
        # Start thread
        self.xss_thread = XSSVulnerabilityScannerThread(url, forms_only, test_all_params)
        self.xss_thread.result_signal.connect(self.handle_xss_results)
        self.xss_thread.progress_signal.connect(self.update_xss_progress)
        self.xss_thread.error_signal.connect(self.handle_xss_error)
        self.xss_thread.start()
    
    def update_xss_progress(self, current, total):
        """Update progress bar for XSS scanning."""
        if total > 0:
            progress = int((current / total) * 100)
            self.xss_progress_bar.setValue(progress)
            self.xss_status_label.setText(f"Scanning for XSS: {current}/{total} ({progress}%)")
    
    def handle_xss_results(self, results):
        """Handle XSS scanning results."""
        self.xss_progress_bar.setValue(100)
        
        if 'vulnerabilities' in results:
            vulns = results['vulnerabilities']
            
            if vulns:
                output = f"Found {len(vulns)} potential XSS vulnerabilities:\n\n"
                
                for i, vuln in enumerate(vulns, 1):
                    output += f"Vulnerability #{i}:\n"
                    output += f"URL: {vuln.get('url', 'Unknown')}\n"
                    output += f"Type: {vuln.get('type', 'Unknown')}\n"
                    output += f"Parameter: {vuln.get('parameter', 'Unknown')}\n"
                    output += f"Payload: {vuln.get('payload', 'Unknown')}\n"
                    output += f"Context: {vuln.get('context', 'Unknown')}\n"
                    output += f"Description: {vuln.get('description', '')}\n"
                    output += "-" * 50 + "\n"
                
                self.xss_results.setText(output)
                self.xss_status_label.setText(f"Found {len(vulns)} potential XSS vulnerabilities")
            else:
                self.xss_results.setText("No XSS vulnerabilities found.")
                self.xss_status_label.setText("No XSS vulnerabilities found")
        else:
            self.xss_results.setText("Scan completed but no results were returned.")
            self.xss_status_label.setText("Scan completed")
        
        # Re-enable UI
        self.xss_scan_button.setEnabled(True)
        self.xss_progress_bar.setVisible(False)
    
    def handle_xss_error(self, error):
        """Handle XSS scanning error."""
        self.xss_status_label.setText(f"Error: {error}")
        self.xss_progress_bar.setValue(0)
        self.xss_progress_bar.setVisible(False)
        self.xss_scan_button.setEnabled(True)
        self.xss_results.setText(f"Error occurred during scan: {error}")
    
    def perform_sql_injection_scan(self):
        """Perform SQL injection scanning in a separate thread."""
        url = self.sql_url_input.text().strip()
        if not url:
            self.sql_status_label.setText("Error: Please enter a URL")
            return
        
        # Add http:// prefix if missing
        if not url.startswith("http://") and not url.startswith("https://"):
            url = "https://" + url
            self.sql_url_input.setText(url)
        
        # Get options
        scan_level = self.sql_scan_level.currentText().lower()
        forms = self.sql_forms_checkbox.isChecked()
        parameters = self.sql_params_checkbox.isChecked()
        timeout_detection = self.sql_timeout_checkbox.isChecked()
        
        # Update UI
        self.sql_scan_button.setEnabled(False)
        self.sql_status_label.setText(f"Scanning {url} for SQL injection vulnerabilities...")
        self.sql_progress_bar.setVisible(True)
        self.sql_progress_bar.setValue(0)
        self.sql_results.clear()
        
        # Start thread
        self.sql_thread = SQLInjectionScannerThread(url, scan_level, forms, parameters, timeout_detection)
        self.sql_thread.result_signal.connect(self.handle_sql_injection_results)
        self.sql_thread.progress_signal.connect(self.update_sql_injection_progress)
        self.sql_thread.error_signal.connect(self.handle_sql_injection_error)
        self.sql_thread.start()
    
    def update_sql_injection_progress(self, data):
        """Update progress bar for SQL injection scanning."""
        current = data.get('current', 0)
        total = data.get('total', 0)
        if total > 0:
            progress = int((current / total) * 100)
            self.sql_progress_bar.setValue(progress)
            self.sql_status_label.setText(f"Scanning for SQL injection: {current}/{total} ({progress}%)")
    
    def handle_sql_injection_results(self, results):
        """Handle SQL injection scanning results."""
        self.sql_progress_bar.setValue(100)
        
        if 'vulnerabilities' in results:
            vulns = results['vulnerabilities']
            
            if vulns:
                output = f"Found {len(vulns)} potential SQL injection vulnerabilities:\n\n"
                
                for i, vuln in enumerate(vulns, 1):
                    output += f"Vulnerability #{i}:\n"
                    output += f"URL: {vuln.get('url', 'Unknown')}\n"
                    output += f"Type: {vuln.get('type', 'Unknown')}\n"
                    output += f"Parameter: {vuln.get('parameter', 'Unknown')}\n"
                    output += f"Payload: {vuln.get('payload', 'Unknown')}\n"
                    output += f"Context: {vuln.get('context', 'Unknown')}\n"
                    output += f"Description: {vuln.get('description', '')}\n"
                    output += "-" * 50 + "\n"
                
                self.sql_results.setText(output)
                self.sql_status_label.setText(f"Found {len(vulns)} potential SQL injection vulnerabilities")
            else:
                self.sql_results.setText("No SQL injection vulnerabilities found.")
                self.sql_status_label.setText("No SQL injection vulnerabilities found")
        else:
            self.sql_results.setText("Scan completed but no results were returned.")
            self.sql_status_label.setText("Scan completed")
        
        # Re-enable UI
        self.sql_scan_button.setEnabled(True)
        self.sql_progress_bar.setVisible(False)
    
    def handle_sql_injection_error(self, error):
        """Handle SQL injection scanning error."""
        self.sql_status_label.setText(f"Error: {error}")
        self.sql_progress_bar.setValue(0)
        self.sql_progress_bar.setVisible(False)
        self.sql_scan_button.setEnabled(True)
        self.sql_results.setText(f"Error occurred during scan: {error}")
    
    def cleanup(self):
        """Clean up resources when closing the tab."""
        # Stop any running threads
        if self.header_thread and self.header_thread.isRunning():
            self.header_thread.terminate()
            self.header_thread.wait()
            
        if self.subdomain_thread and self.subdomain_thread.isRunning():
            self.subdomain_thread.terminate()
            self.subdomain_thread.wait()
            
        if self.xss_thread and self.xss_thread.isRunning():
            self.xss_thread.terminate()
            self.xss_thread.wait()
            
        if self.sql_thread and self.sql_thread.isRunning():
            self.sql_thread.terminate()
            self.sql_thread.wait()
    
    # Add event handlers for tab visibility changes
    def showEvent(self, event):
        """Handle when the tab becomes visible"""
        super().showEvent(event)
        self.is_visible = True
        print("Web Pentest tab is now visible")
        
        # Reset status labels to Ready state
        if hasattr(self, 'header_status'):
            self.header_status.setText("Ready")
        if hasattr(self, 'subdomain_status'):
            self.subdomain_status.setText("Ready")
        if hasattr(self, 'xss_status'):
            self.xss_status.setText("Ready")
        if hasattr(self, 'sql_status'):
            self.sql_status.setText("Ready")
        
    def hideEvent(self, event):
        """Handle when the tab becomes hidden"""
        super().hideEvent(event)
        self.is_visible = False
        print("Web Pentest tab is now hidden")
        
        # Clean up any ongoing operations
        self.cleanup()
        
    def cleanup(self):
        """Clean up resources when the tab is hidden or closed."""
        # Stop any running threads
        threads = [
            (hasattr(self, 'header_thread') and self.header_thread),
            (hasattr(self, 'subdomain_thread') and self.subdomain_thread),
            (hasattr(self, 'xss_thread') and self.xss_thread),
            (hasattr(self, 'sql_thread') and self.sql_thread)
        ]
        
        for thread in threads:
            if thread and thread.isRunning():
                try:
                    thread.terminate()
                    thread.wait()
                except Exception as e:
                    print(f"Error cleaning up thread: {str(e)}")