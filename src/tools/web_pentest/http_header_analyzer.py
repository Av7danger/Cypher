import requests
import re
import ssl
import socket
import datetime
from urllib.parse import urlparse


class HTTPHeaderAnalyzer:
    """Tool for analyzing HTTP headers for security issues and configuration weaknesses."""
    
    def __init__(self):
        # Default timeout for requests
        self.timeout = 10
        
        # User agent to use for requests
        self.user_agent = "Cypher-Security-Toolkit/1.0"
        
        # Security headers to check
        self.security_headers = {
            'strict-transport-security': {
                'description': 'HTTP Strict Transport Security (HSTS)',
                'importance': 'high',
                'recommended': 'max-age=31536000; includeSubDomains; preload',
                'info': 'Enforces secure (HTTPS) connections to the server'
            },
            'content-security-policy': {
                'description': 'Content Security Policy (CSP)',
                'importance': 'high',
                'recommended': 'Default policy with appropriate restrictions',
                'info': 'Helps prevent Cross-Site Scripting (XSS) and data injection attacks'
            },
            'x-content-type-options': {
                'description': 'X-Content-Type-Options',
                'importance': 'medium',
                'recommended': 'nosniff',
                'info': 'Prevents browser from MIME-sniffing a response from declared content-type'
            },
            'x-frame-options': {
                'description': 'X-Frame-Options',
                'importance': 'medium',
                'recommended': 'SAMEORIGIN or DENY',
                'info': 'Protects against clickjacking attacks'
            },
            'x-xss-protection': {
                'description': 'X-XSS-Protection',
                'importance': 'medium',
                'recommended': '1; mode=block',
                'info': 'Enables browser\'s XSS filtering'
            },
            'referrer-policy': {
                'description': 'Referrer Policy',
                'importance': 'medium',
                'recommended': 'no-referrer, strict-origin or strict-origin-when-cross-origin',
                'info': 'Controls how much referrer information is sent with requests'
            },
            'permissions-policy': {
                'description': 'Permissions Policy',
                'importance': 'medium',
                'recommended': 'Restrict unnecessary browser features',
                'info': 'Controls which browser features can be used (successor to Feature-Policy)'
            },
            'cache-control': {
                'description': 'Cache Control',
                'importance': 'medium',
                'recommended': 'no-cache, no-store, must-revalidate (for sensitive data)',
                'info': 'Directs how content should be cached by browsers and intermediaries'
            },
            'clear-site-data': {
                'description': 'Clear Site Data',
                'importance': 'low',
                'recommended': '"cache","cookies","storage" (for logout endpoints)',
                'info': 'Clears browsing data (cache, cookies, storage, etc.)'
            },
            'cross-origin-embedder-policy': {
                'description': 'Cross-Origin Embedder Policy',
                'importance': 'low',
                'recommended': 'require-corp',
                'info': 'Controls which resources can be loaded cross-origin'
            },
            'cross-origin-opener-policy': {
                'description': 'Cross-Origin Opener Policy',
                'importance': 'low',
                'recommended': 'same-origin',
                'info': 'Controls if cross-origin document sharing is allowed'
            },
            'cross-origin-resource-policy': {
                'description': 'Cross-Origin Resource Policy',
                'importance': 'low',
                'recommended': 'same-origin or same-site',
                'info': 'Controls which websites can load this resource'
            },
        }
        
        # Cookie flags to check
        self.cookie_flags = {
            'httponly': {
                'description': 'HttpOnly Flag',
                'importance': 'high',
                'info': 'Prevents client-side scripts from accessing cookies'
            },
            'secure': {
                'description': 'Secure Flag',
                'importance': 'high',
                'info': 'Ensures cookies are only sent over HTTPS'
            },
            'samesite': {
                'description': 'SameSite Attribute',
                'importance': 'medium',
                'info': 'Controls when cookies are sent with cross-site requests'
            },
            'max-age': {
                'description': 'Max-Age/Expires',
                'importance': 'medium',
                'info': 'Defines when the cookie expires'
            },
            'path': {
                'description': 'Path Attribute',
                'importance': 'low',
                'info': 'Limits cookies to specific directories'
            },
            'domain': {
                'description': 'Domain Attribute',
                'importance': 'low',
                'info': 'Defines the domain scope of the cookie'
            }
        }
    
    def analyze(self, url, check_ssl=True):
        """
        Analyze HTTP headers for a given URL.
        
        Args:
            url: URL to analyze
            check_ssl: Whether to check SSL/TLS configuration
            
        Returns:
            Dictionary with header analysis, issues, and recommendations
        """
        # Ensure URL has protocol
        if not url.startswith('http://') and not url.startswith('https://'):
            url = 'https://' + url
            
        try:
            parsed_url = urlparse(url)
            
            # Check if URL is valid
            if not parsed_url.netloc:
                return {'error': 'Invalid URL format'}
                
            # Make HTTP request
            headers = {'User-Agent': self.user_agent}
            response = requests.get(url, headers=headers, timeout=self.timeout, allow_redirects=True)
            
            # Store response headers
            response_headers = {k.lower(): v for k, v in response.headers.items()}
            
            # Check security headers
            security_header_analysis = self._analyze_security_headers(response_headers)
            
            # Analyze cookies
            cookie_analysis = self._analyze_cookies(response.cookies)
            
            # Get server info
            server_info = self._extract_server_info(response_headers)
            
            # Check redirects
            redirect_analysis = self._analyze_redirects(response.history)
            
            # SSL/TLS analysis if requested and using HTTPS
            ssl_analysis = None
            if check_ssl and parsed_url.scheme == 'https':
                ssl_analysis = self._check_ssl(parsed_url.netloc)
            
            # Analyze other interesting headers
            other_headers_analysis = self._analyze_other_headers(response_headers)
            
            # Generate overall security score
            security_score = self._calculate_security_score(
                security_header_analysis, 
                cookie_analysis,
                ssl_analysis
            )
            
            # Generate recommendations
            recommendations = self._generate_recommendations(
                security_header_analysis, 
                cookie_analysis,
                ssl_analysis
            )
            
            return {
                'url': url,
                'status_code': response.status_code,
                'server_info': server_info,
                'all_headers': dict(response.headers),
                'security_headers': security_header_analysis,
                'cookies': cookie_analysis,
                'redirect_chain': redirect_analysis,
                'ssl_analysis': ssl_analysis,
                'other_headers': other_headers_analysis,
                'security_score': security_score,
                'recommendations': recommendations
            }
            
        except requests.exceptions.RequestException as e:
            return {'error': f'Error making request: {str(e)}'}
        except Exception as e:
            return {'error': f'Error analyzing headers: {str(e)}'}
    
    def _analyze_security_headers(self, headers):
        """
        Analyze security headers from the response.
        
        Args:
            headers: Dictionary of response headers
            
        Returns:
            Dictionary with analysis of security headers
        """
        analysis = {}
        
        # Check each security header
        for header_name, header_info in self.security_headers.items():
            if header_name in headers:
                value = headers[header_name]
                analysis[header_name] = {
                    'present': True,
                    'value': value,
                    'description': header_info['description'],
                    'recommendation': self._check_header_value(header_name, value),
                    'importance': header_info['importance'],
                }
            else:
                analysis[header_name] = {
                    'present': False,
                    'description': header_info['description'],
                    'recommendation': f"Add the {header_info['description']} header with recommended value: {header_info['recommended']}",
                    'importance': header_info['importance'],
                }
        
        return analysis
    
    def _check_header_value(self, header_name, value):
        """
        Check if the header value meets recommended settings.
        
        Args:
            header_name: Name of the header
            value: Current value of the header
            
        Returns:
            Recommendation string or None if value is good
        """
        header_info = self.security_headers[header_name]
        
        # HSTS check
        if header_name == 'strict-transport-security':
            if 'max-age=' not in value.lower():
                return "HSTS header missing max-age directive"
            
            # Extract max-age value
            max_age_match = re.search(r'max-age=(\d+)', value.lower())
            if max_age_match:
                max_age = int(max_age_match.group(1))
                if max_age < 31536000:  # One year in seconds
                    return "HSTS max-age is less than recommended (1 year)"
                    
            if 'includesubdomains' not in value.lower():
                return "Consider adding 'includeSubDomains' directive to HSTS"
                
            # No issues found
            return None
        
        # CSP check - just basic check
        elif header_name == 'content-security-policy':
            if "default-src 'none'" in value or "default-src 'self'" in value:
                # Has a reasonable default policy
                return None
            elif "default-src" not in value:
                return "CSP missing default-src directive"
            else:
                return None  # Basic CSP present
        
        # X-Content-Type-Options
        elif header_name == 'x-content-type-options':
            if value.lower() != 'nosniff':
                return "X-Content-Type-Options should be set to 'nosniff'"
            return None
        
        # X-Frame-Options
        elif header_name == 'x-frame-options':
            if value.upper() not in ['DENY', 'SAMEORIGIN']:
                return "X-Frame-Options should be set to 'DENY' or 'SAMEORIGIN'"
            return None
        
        # X-XSS-Protection
        elif header_name == 'x-xss-protection':
            if value != '1; mode=block':
                return "X-XSS-Protection should be set to '1; mode=block'"
            return None
        
        # For other headers, no specific value check
        return None
    
    def _analyze_cookies(self, cookies):
        """
        Analyze cookies for security best practices.
        
        Args:
            cookies: Cookies from the response
            
        Returns:
            Dictionary with cookie analysis
        """
        cookie_analysis = {
            'count': len(cookies),
            'cookies': [],
            'issues': []
        }
        
        for cookie in cookies:
            cookie_info = {
                'name': cookie.name,
                'domain': cookie.domain,
                'path': cookie.path,
                'secure': cookie.secure,
                'httponly': cookie.has_nonstandard_attr('HttpOnly') or cookie.has_nonstandard_attr('httponly'),
                'samesite': None,
                'expires': cookie.expires
            }
            
            # Check for SameSite attribute
            for attr in cookie._rest.keys():
                if attr.lower() == 'samesite':
                    cookie_info['samesite'] = cookie._rest[attr]
            
            # Check for issues
            if not cookie_info['secure']:
                cookie_analysis['issues'].append(f"Cookie '{cookie.name}' missing Secure flag")
                
            if not cookie_info['httponly']:
                cookie_analysis['issues'].append(f"Cookie '{cookie.name}' missing HttpOnly flag")
                
            if not cookie_info['samesite']:
                cookie_analysis['issues'].append(f"Cookie '{cookie.name}' missing SameSite attribute")
            
            cookie_analysis['cookies'].append(cookie_info)
        
        return cookie_analysis
    
    def _extract_server_info(self, headers):
        """
        Extract server information from headers.
        
        Args:
            headers: Dictionary of response headers
            
        Returns:
            Dictionary with server information
        """
        server_info = {
            'server': headers.get('server', 'Not disclosed'),
            'powered_by': headers.get('x-powered-by', 'Not disclosed'),
            'backend': headers.get('x-backend', headers.get('x-backend-server', 'Not disclosed')),
            'through': headers.get('via', 'Not disclosed'),
            'cdn': None,
        }
        
        # Try to identify CDN
        cdn_headers = {
            'cloudflare': ['cf-ray', 'cf-cache-status'],
            'fastly': ['fastly-io-info', 'x-served-by'],
            'akamai': ['x-akamai-transformed', 'akamai-grn'],
            'cloudfront': ['x-amz-cf-id'],
            'vercel': ['x-vercel-id'],
            'netlify': ['x-nf-request-id'],
        }
        
        for cdn, cdn_header_list in cdn_headers.items():
            for header in cdn_header_list:
                if header in headers:
                    server_info['cdn'] = cdn
                    break
            if server_info['cdn']:
                break
        
        return server_info
    
    def _analyze_redirects(self, history):
        """
        Analyze the redirect chain.
        
        Args:
            history: Response history from requests
            
        Returns:
            Dictionary with redirect analysis
        """
        redirects = []
        
        for r in history:
            redirects.append({
                'url': r.url,
                'status_code': r.status_code,
                'location': r.headers.get('location', 'Not specified')
            })
        
        redirect_analysis = {
            'count': len(redirects),
            'chain': redirects,
            'issues': []
        }
        
        # Check for potential issues
        if len(redirects) > 3:
            redirect_analysis['issues'].append(f"Long redirect chain ({len(redirects)} redirects)")
            
        # Check for HTTP to HTTPS redirects
        for redirect in redirects:
            if redirect['url'].startswith('http://') and redirect.get('location', '').startswith('https://'):
                redirect_analysis['issues'].append("HTTP to HTTPS redirect (good for security)")
        
        return redirect_analysis
    
    def _check_ssl(self, hostname):
        """
        Check SSL/TLS configuration.
        
        Args:
            hostname: Hostname to check
            
        Returns:
            Dictionary with SSL/TLS analysis
        """
        try:
            # Get hostname and port
            host = hostname
            port = 443
            if ':' in hostname:
                host, port_str = hostname.split(':')
                port = int(port_str)
                
            # Create SSL context
            context = ssl.create_default_context()
            
            with socket.create_connection((host, port), timeout=self.timeout) as sock:
                with context.wrap_socket(sock, server_hostname=host) as ssock:
                    # Get certificate
                    cert = ssock.getpeercert()
                    cipher = ssock.cipher()
                    
                    # Parse certificate details
                    issued_to = dict(x[0] for x in cert['subject'])
                    issued_by = dict(x[0] for x in cert['issuer'])
                    
                    # Check validity
                    not_after = datetime.datetime.strptime(cert['notAfter'], '%b %d %H:%M:%S %Y %Z')
                    days_left = (not_after - datetime.datetime.now()).days
                    
                    # Check for Extended Validation
                    is_ev = False
                    if 'organizationName' in issued_to and 'organizationalUnitName' in issued_to:
                        is_ev = True
                    
                    # Get the protocol version
                    protocol = ssock.version()
                    
                    ssl_info = {
                        'certificate': {
                            'common_name': issued_to.get('commonName'),
                            'organization': issued_to.get('organizationName', 'Not specified'),
                            'issuer': issued_by.get('commonName'),
                            'valid_until': cert['notAfter'],
                            'days_left': days_left,
                            'alt_names': cert.get('subjectAltName', []),
                            'serial_number': cert.get('serialNumber'),
                            'version': cert.get('version'),
                            'is_ev': is_ev
                        },
                        'connection': {
                            'protocol': protocol,
                            'cipher_suite': cipher[0],
                            'key_exchange': cipher[1],
                            'mac': cipher[2]
                        },
                        'issues': []
                    }
                    
                    # Check for issues
                    if days_left < 30:
                        ssl_info['issues'].append(f"Certificate expires soon ({days_left} days)")
                    
                    if protocol in ['SSLv2', 'SSLv3', 'TLSv1', 'TLSv1.1']:
                        ssl_info['issues'].append(f"Using outdated protocol: {protocol}")
                    
                    return ssl_info
                    
        except ssl.SSLError as e:
            return {'error': f"SSL Error: {str(e)}"}
        except socket.error as e:
            return {'error': f"Connection Error: {str(e)}"}
        except Exception as e:
            return {'error': f"Error checking SSL: {str(e)}"}
    
    def _analyze_other_headers(self, headers):
        """
        Analyze other interesting headers.
        
        Args:
            headers: Dictionary of response headers
            
        Returns:
            Dictionary with analysis of other headers
        """
        other_headers = {}
        
        # Interesting headers to check
        interesting_headers = [
            'access-control-allow-origin',
            'access-control-allow-methods',
            'access-control-allow-headers',
            'access-control-expose-headers',
            'access-control-max-age',
            'access-control-allow-credentials',
            'timing-allow-origin',
            'vary',
            'age',
            'set-cookie'
        ]
        
        for header in interesting_headers:
            if header in headers:
                other_headers[header] = headers[header]
        
        return other_headers
    
    def _calculate_security_score(self, security_headers, cookie_analysis, ssl_analysis=None):
        """
        Calculate an overall security score based on headers and SSL.
        
        Args:
            security_headers: Security headers analysis
            cookie_analysis: Cookie analysis
            ssl_analysis: SSL/TLS analysis
            
        Returns:
            Dictionary with score and rating
        """
        score = 0
        max_score = 0
        
        # Score security headers
        for header, analysis in security_headers.items():
            importance_weight = {
                'high': 10,
                'medium': 5,
                'low': 2
            }.get(analysis['importance'], 1)
            
            max_score += importance_weight
            
            if analysis['present']:
                # Full points if present with no recommendation
                if analysis.get('recommendation') is None:
                    score += importance_weight
                # Half points if present but with recommendations
                else:
                    score += importance_weight / 2
        
        # Score cookies
        cookie_issues = len(cookie_analysis.get('issues', []))
        if cookie_issues == 0:
            score += 15
        elif cookie_issues <= 2:
            score += 8
        else:
            score += 3
        max_score += 15
        
        # Score SSL/TLS if available
        if ssl_analysis and 'error' not in ssl_analysis:
            max_score += 20
            ssl_issues = len(ssl_analysis.get('issues', []))
            
            if ssl_issues == 0:
                score += 20
            elif ssl_issues == 1:
                score += 12
            else:
                score += 5
        
        # Calculate percentage
        percentage = int((score / max_score) * 100) if max_score > 0 else 0
        
        # Determine rating
        rating = 'F'
        if percentage >= 90:
            rating = 'A+'
        elif percentage >= 80:
            rating = 'A'
        elif percentage >= 70:
            rating = 'B'
        elif percentage >= 60:
            rating = 'C'
        elif percentage >= 50:
            rating = 'D'
        
        return {
            'score': percentage,
            'rating': rating,
            'max_points': max_score,
            'points_earned': score
        }
    
    def _generate_recommendations(self, security_headers, cookie_analysis, ssl_analysis=None):
        """
        Generate security recommendations based on the analysis.
        
        Args:
            security_headers: Security headers analysis
            cookie_analysis: Cookie analysis
            ssl_analysis: SSL/TLS analysis
            
        Returns:
            List of recommendations
        """
        recommendations = []
        
        # Add header recommendations
        for header, analysis in security_headers.items():
            if not analysis['present']:
                importance = analysis.get('importance', 'medium')
                header_info = self.security_headers.get(header, {})
                
                if importance == 'high':
                    recommendations.append({
                        'priority': 'high',
                        'category': 'security_header',
                        'text': f"Add the {header_info.get('description', header)} header: {header_info.get('recommended', '')}"
                    })
                elif importance == 'medium':
                    recommendations.append({
                        'priority': 'medium',
                        'category': 'security_header',
                        'text': f"Consider adding the {header_info.get('description', header)} header: {header_info.get('recommended', '')}"
                    })
            elif analysis.get('recommendation'):
                recommendations.append({
                    'priority': 'medium',
                    'category': 'security_header',
                    'text': analysis['recommendation']
                })
        
        # Add cookie recommendations
        for issue in cookie_analysis.get('issues', []):
            recommendations.append({
                'priority': 'high',
                'category': 'cookie',
                'text': issue
            })
        
        # Add SSL recommendations
        if ssl_analysis and 'error' not in ssl_analysis:
            for issue in ssl_analysis.get('issues', []):
                recommendations.append({
                    'priority': 'high',
                    'category': 'ssl',
                    'text': issue
                })
        
        return recommendations