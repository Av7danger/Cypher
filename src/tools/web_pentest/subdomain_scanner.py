import dns.resolver
import concurrent.futures
import threading
import time
import re


class SubdomainScanner:
    """Tool for discovering subdomains of a given domain using various techniques."""
    
    def __init__(self):
        # DNS resolver configuration
        self.resolver = dns.resolver.Resolver()
        self.resolver.timeout = 2.0
        self.resolver.lifetime = 2.0
        
        # Default DNS servers (Google's public DNS)
        self.resolver.nameservers = ['8.8.8.8', '8.8.4.4']
        
        # Dictionary for common subdomain prefixes
        self.common_subdomains = [
            'www', 'mail', 'ftp', 'localhost', 'webmail', 'smtp', 'pop', 'ns1', 'ns2',
            'ns3', 'ns4', 'webdisk', 'pop3', 'admin', 'forum', 'blog', 'portal', 'test',
            'host', 'dns', 'mx', 'local', 'exchange', 'api', 'dev', 'support', 'secure',
            'shop', 'demo', 'm', 'cms', 'app', 'media', 'static', 'developer', 'news',
            'cpanel', 'cloud', 'autodiscover', 'login', 'staging', 'en', 'mobile', 'wiki',
            'help', 'remote', 'server', 'status', 'beta', 'intranet', 'file', 'chat',
            'sip', 'corp', 'vpn', 'jira', 'internal', 'download', 'dashboard', 'img',
            'docs', 'upload', 'content', 'cdn', 'auth', 'sql', 'services', 'live',
            'jenkins', 'gitlab', 'git', 'assets', 'tickets', 'clients', 'client',
            'partner', 'partners', 'web', 'data', 'office', 'newsletter', 'alerts',
            'monitor', 'gw', 'gateway'
        ]
        
        # Result storage
        self.found_subdomains = set()
        self.results_lock = threading.Lock()
        
        # Scan control
        self.stop_scan = False
        self.is_scanning = False
    
    def scan(self, domain, techniques=None, max_threads=10, callback=None):
        """
        Scan for subdomains of a given domain using multiple techniques.
        
        Args:
            domain: Base domain to scan for subdomains
            techniques: List of techniques to use ('bruteforce', 'dns', 'crt.sh')
                        Default: all techniques
            max_threads: Maximum number of concurrent threads for brute force
            callback: Function to call with periodic updates (receives list of found subdomains)
            
        Returns:
            Dictionary with scan results and statistics
        """
        if not domain:
            return {'error': 'No domain specified'}
            
        # Validate domain format
        if not self._is_valid_domain(domain):
            return {'error': f'Invalid domain format: {domain}'}
        
        # Ensure domain is normalized (remove protocol, www, etc.)
        domain = self._normalize_domain(domain)
        
        # Set available techniques
        available_techniques = {
            'bruteforce': self._scan_bruteforce,
            'dns': self._scan_dns_records,
            'crt': self._scan_certificate_transparency
        }
        
        # Default to all techniques if none specified
        if not techniques:
            techniques = list(available_techniques.keys())
        
        # Reset scan control
        self.stop_scan = False
        self.is_scanning = True
        self.found_subdomains = set()
        
        # Start time
        start_time = time.time()
        
        # Create callback thread if needed
        callback_thread = None
        if callback:
            callback_thread = threading.Thread(
                target=self._callback_updater,
                args=(callback, domain)
            )
            callback_thread.daemon = True
            callback_thread.start()
        
        # Execute each technique
        try:
            for technique in techniques:
                if technique in available_techniques and not self.stop_scan:
                    available_techniques[technique](domain, max_threads)
        
        except Exception as e:
            self.is_scanning = False
            return {'error': f'Error during subdomain scanning: {str(e)}'}
            
        finally:
            # Scan complete
            self.is_scanning = False
            
            # Wait for callback thread to exit
            if callback_thread:
                callback_thread.join(timeout=1.0)
        
        # Calculate scan time
        scan_time = time.time() - start_time
        
        # Format results
        results = sorted(list(self.found_subdomains))
        
        return {
            'domain': domain,
            'subdomains': results,
            'count': len(results),
            'techniques_used': techniques,
            'scan_time_seconds': round(scan_time, 2)
        }
    
    def stop(self):
        """Stop an ongoing scan."""
        self.stop_scan = True
        return {'status': 'stopping'}
    
    def _normalize_domain(self, domain):
        """Normalize a domain by removing protocol, www, paths, etc."""
        # Remove protocol
        domain = re.sub(r'^https?://', '', domain)
        
        # Remove path and query string
        domain = domain.split('/')[0]
        
        # Remove port if present
        domain = domain.split(':')[0]
        
        # Remove 'www.' prefix if present
        domain = re.sub(r'^www\.', '', domain)
        
        return domain.lower()
    
    def _is_valid_domain(self, domain):
        """Check if a string is a valid domain name."""
        if not domain:
            return False
            
        # Normalize domain first
        domain = self._normalize_domain(domain)
        
        # Check domain pattern
        pattern = r'^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$'
        return bool(re.match(pattern, domain))
    
    def _scan_bruteforce(self, domain, max_threads):
        """
        Brute force subdomains by testing common subdomain prefixes.
        
        Args:
            domain: Base domain to scan
            max_threads: Maximum number of concurrent threads
        """
        with concurrent.futures.ThreadPoolExecutor(max_workers=max_threads) as executor:
            # Submit tasks for each subdomain prefix
            futures = {executor.submit(self._check_subdomain, f"{sub}.{domain}"): sub 
                       for sub in self.common_subdomains if not self.stop_scan}
            
            # Process completed futures
            for future in concurrent.futures.as_completed(futures):
                if self.stop_scan:
                    break
                # Results are collected in _check_subdomain via found_subdomains set
    
    def _scan_dns_records(self, domain, max_threads):
        """
        Scan DNS records for potential subdomains.
        
        Args:
            domain: Base domain to scan
            max_threads: Not used for this technique
        """
        if self.stop_scan:
            return
            
        # Check common DNS record types that might reveal subdomains
        record_types = ['NS', 'MX', 'CNAME', 'TXT']
        
        for record_type in record_types:
            if self.stop_scan:
                break
                
            try:
                answers = self.resolver.resolve(domain, record_type)
                
                for answer in answers:
                    answer_str = str(answer)
                    
                    # Extract potential subdomains from the answer
                    self._extract_subdomains_from_text(answer_str, domain)
                    
            except (dns.resolver.NoAnswer, dns.resolver.NXDOMAIN, dns.exception.Timeout):
                continue
            except Exception:
                continue
    
    def _scan_certificate_transparency(self, domain, max_threads):
        """
        Scan Certificate Transparency logs for subdomains.
        Uses crt.sh website which aggregates CT logs.
        
        Args:
            domain: Base domain to scan
            max_threads: Not used for this technique
        """
        if self.stop_scan:
            return
            
        try:
            # We simulate an API request to crt.sh here
            # In a real implementation, you'd use the crt.sh JSON API or database
            # For demonstration, we'll just simulate finding some subdomains
            
            # This is a simplified approach. In a real implementation,
            # you would make an actual HTTP request to:
            # https://crt.sh/?q=<domain>&output=json
            
            # Simulate some found subdomains
            potential_subs = [
                f"api.{domain}",
                f"mail.{domain}",
                f"login.{domain}",
                f"dev.{domain}",
                f"staging.{domain}",
                f"test.{domain}",
                f"admin.{domain}",
                f"secure.{domain}",
                f"shop.{domain}",
                f"m.{domain}"
            ]
            
            for subdomain in potential_subs:
                if self.stop_scan:
                    break
                    
                # Verify the subdomain exists
                self._check_subdomain(subdomain)
                
        except Exception:
            # Silently fail if the CT scan doesn't work
            pass
    
    def _check_subdomain(self, subdomain):
        """
        Check if a subdomain exists by attempting DNS resolution.
        
        Args:
            subdomain: Full subdomain to check
            
        Returns:
            True if the subdomain exists, False otherwise
        """
        try:
            # Try to resolve the subdomain
            self.resolver.resolve(subdomain, 'A')
            
            # If it succeeds, add to found subdomains
            with self.results_lock:
                self.found_subdomains.add(subdomain)
                
            return True
            
        except (dns.resolver.NoAnswer, dns.resolver.NXDOMAIN, dns.exception.Timeout, dns.resolver.NoNameservers):
            # Also try AAAA record before giving up
            try:
                self.resolver.resolve(subdomain, 'AAAA')
                
                # If it succeeds, add to found subdomains
                with self.results_lock:
                    self.found_subdomains.add(subdomain)
                    
                return True
                
            except (dns.resolver.NoAnswer, dns.resolver.NXDOMAIN, dns.exception.Timeout, dns.resolver.NoNameservers):
                return False
                
        except Exception:
            return False
    
    def _extract_subdomains_from_text(self, text, domain):
        """
        Extract potential subdomains from text like DNS records.
        
        Args:
            text: Text to search for subdomains
            domain: Base domain to filter subdomain matches
        """
        # Pattern to find subdomains
        pattern = r'([a-zA-Z0-9][-a-zA-Z0-9]*\.)+' + re.escape(domain)
        
        # Find all matches
        matches = re.findall(pattern, text)
        
        # Add matches to found subdomains
        for match in matches:
            if match.endswith('.' + domain):
                full_subdomain = match
                with self.results_lock:
                    self.found_subdomains.add(full_subdomain)
    
    def _callback_updater(self, callback, domain):
        """
        Periodically call the callback function with current results.
        
        Args:
            callback: Function to call with updates
            domain: Base domain being scanned
        """
        while self.is_scanning:
            # Create a copy of current results
            with self.results_lock:
                current_results = sorted(list(self.found_subdomains))
            
            # Call the callback
            callback({
                'domain': domain,
                'subdomains': current_results,
                'count': len(current_results),
                'status': 'scanning'
            })
            
            # Wait before next update
            time.sleep(2.0)