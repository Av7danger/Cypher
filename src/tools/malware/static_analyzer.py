#!/usr/bin/env python3
"""Static malware analysis tool for the Cypher Security Toolkit."""
import os
import re
import hashlib
import pefile
import string
from typing import Dict, List, Optional, Set, Tuple, Union

class StaticAnalyzer:
    """Perform static analysis on potentially malicious files."""
    
    def __init__(self):
        """Initialize the static analyzer."""
        # Common suspicious API calls that may indicate malicious activity
        self.suspicious_apis = [
            # File operations
            "CreateFile", "WriteFile", "ReadFile", "DeleteFile", "CopyFile",
            # Registry operations
            "RegOpenKey", "RegCreateKey", "RegSetValue", "RegDeleteKey",
            # Process/thread operations
            "CreateProcess", "CreateThread", "CreateRemoteThread", "VirtualAlloc",
            "VirtualProtect", "OpenProcess", "TerminateProcess",
            # Network operations
            "socket", "connect", "bind", "send", "recv", "WSAStartup",
            "InternetOpen", "InternetConnect", "HttpOpenRequest", "HttpSendRequest",
            # Persistence
            "SetWindowsHook", "CreateService", "StartService",
            # Anti-analysis
            "IsDebuggerPresent", "CheckRemoteDebuggerPresent", "GetTickCount",
            "QueryPerformanceCounter", "Sleep", "GetSystemTime"
        ]
        
        # Common suspicious strings/patterns
        self.suspicious_patterns = [
            # Command execution
            re.compile(r'cmd\.exe|powershell\.exe|bash\.exe|sh\s+-c'),
            # Encoded commands
            re.compile(r'base64 -d|encodedcommand'),
            # URLs and IPs
            re.compile(r'https?://[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}'),
            re.compile(r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}'),
            # File paths 
            re.compile(r'\\Windows\\Temp|\\AppData\\Local\\Temp|\\ProgramData\\'),
            # Registry
            re.compile(r'HKEY_|CurrentVersion\\Run|\\Software\\Microsoft\\Windows'),
            # Scripts
            re.compile(r'\.vbs|\.ps1|\.bat|\.cmd')
        ]
    
    def is_pe_file(self, file_path: str) -> bool:
        """Check if a file is a PE (Portable Executable) file.
        
        Args:
            file_path: Path to file to check
            
        Returns:
            True if file is a PE file, False otherwise
        """
        try:
            with open(file_path, 'rb') as f:
                header = f.read(2)
                return header == b'MZ'
        except Exception:
            return False
    
    def extract_strings(self, file_path: str, min_length: int = 4) -> List[str]:
        """Extract ASCII and Unicode strings from a binary file.
        
        Args:
            file_path: Path to the file
            min_length: Minimum string length to extract
            
        Returns:
            List of strings found in the file
        """
        strings_found = []
        printable = set(string.printable)
        
        try:
            with open(file_path, 'rb') as f:
                data = f.read()
                
            # ASCII strings
            result = re.findall(b'[\x20-\x7E]{' + str(min_length).encode() + b',}', data)
            strings_found.extend([r.decode('ascii') for r in result])
            
            # Unicode strings
            result = re.findall(b'(?:[\x20-\x7E]\x00){' + str(min_length).encode() + b',}', data)
            strings_found.extend([r.decode('utf-16le') for r in result])
            
            return list(set(strings_found))  # Remove duplicates
        except Exception as e:
            print(f"Error extracting strings: {str(e)}")
            return []
    
    def analyze_pe_file(self, file_path: str) -> Dict:
        """Analyze a PE file for suspicious characteristics.
        
        Args:
            file_path: Path to the PE file
            
        Returns:
            Dict with analysis results
        """
        result = {
            'file_type': 'PE Executable',
            'sections': [],
            'imports': {},
            'suspicious_imports': [],
            'entropy': []
        }
        
        try:
            pe = pefile.PE(file_path)
            
            # Get sections info
            for section in pe.sections:
                section_name = section.Name.strip(b'\x00').decode('utf-8', errors='ignore')
                section_info = {
                    'name': section_name,
                    'virtual_address': hex(section.VirtualAddress),
                    'virtual_size': section.Misc_VirtualSize,
                    'raw_size': section.SizeOfRawData,
                    'entropy': section.get_entropy()
                }
                result['sections'].append(section_info)
                result['entropy'].append((section_name, section.get_entropy()))
            
            # Get imports
            if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT'):
                for entry in pe.DIRECTORY_ENTRY_IMPORT:
                    dll_name = entry.dll.decode('utf-8', errors='ignore')
                    imports = []
                    
                    for imp in entry.imports:
                        if imp.name:
                            api_name = imp.name.decode('utf-8', errors='ignore')
                            imports.append(api_name)
                            
                            if api_name in self.suspicious_apis:
                                result['suspicious_imports'].append((dll_name, api_name))
                    
                    result['imports'][dll_name] = imports
            
            return result
        except Exception as e:
            return {'error': f"PE analysis failed: {str(e)}"}
    
    def analyze_file(self, file_path: str) -> Dict:
        """Analyze a file for suspicious characteristics.
        
        Args:
            file_path: Path to the file to analyze
            
        Returns:
            Dict with analysis results
        """
        if not os.path.isfile(file_path):
            return {'error': f"File not found: {file_path}"}
        
        result = {
            'file_path': file_path,
            'file_size': os.path.getsize(file_path),
            'strings': {
                'suspicious': [],
                'total_extracted': 0
            }
        }
        
        # Extract and analyze strings
        strings = self.extract_strings(file_path)
        result['strings']['total_extracted'] = len(strings)
        
        # Look for suspicious patterns in strings
        for string in strings:
            for pattern in self.suspicious_patterns:
                if pattern.search(string):
                    result['strings']['suspicious'].append(string)
                    break
        
        # PE specific analysis
        if self.is_pe_file(file_path):
            result.update(self.analyze_pe_file(file_path))
        
        return result
    
    def format_results(self, results: Dict) -> str:
        """Format analysis results as human-readable text.
        
        Args:
            results: Dict with analysis results
            
        Returns:
            Formatted string with results
        """
        output = []
        output.append("=== Static Analysis Results ===")
        
        if 'error' in results:
            output.append(f"Error: {results['error']}")
            return '\n'.join(output)
        
        output.append(f"File: {results['file_path']}")
        output.append(f"Size: {results['file_size']} bytes")
        
        if 'file_type' in results:
            output.append(f"Type: {results['file_type']}")
        
        # Output PE sections if available
        if 'sections' in results and results['sections']:
            output.append("\nPE Sections:")
            for section in results['sections']:
                output.append(f"  {section['name']} - Size: {section['raw_size']} bytes, " +
                            f"Entropy: {section['entropy']:.2f}")
        
        # Output suspicious imports if available
        if 'suspicious_imports' in results and results['suspicious_imports']:
            output.append("\nSuspicious API Imports:")
            for dll, api in results['suspicious_imports']:
                output.append(f"  {dll}:{api}")
        
        # Output suspicious strings
        output.append("\nSuspicious Strings Found:")
        if results['strings']['suspicious']:
            for string in sorted(set(results['strings']['suspicious']))[:10]:  # Show top 10
                output.append(f"  {string}")
            
            if len(results['strings']['suspicious']) > 10:
                output.append(f"  ... and {len(results['strings']['suspicious']) - 10} more")
        else:
            output.append("  None found")
        
        output.append(f"\nTotal strings extracted: {results['strings']['total_extracted']}")
        
        # Output high entropy sections (potential encryption/packing)
        high_entropy = [(name, entropy) for name, entropy in results.get('entropy', []) if entropy > 7.0]
        if high_entropy:
            output.append("\nHigh Entropy Sections (potential packing/encryption):")
            for name, entropy in high_entropy:
                output.append(f"  {name}: {entropy:.2f}")
        
        return '\n'.join(output)


if __name__ == '__main__':
    # Simple test
    import sys
    
    if len(sys.argv) != 2:
        print(f"Usage: {sys.argv[0]} <file_path>")
        sys.exit(1)
    
    analyzer = StaticAnalyzer()
    results = analyzer.analyze_file(sys.argv[1])
    print(analyzer.format_results(results))